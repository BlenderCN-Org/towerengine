//-----------------------------------------------------------------------
// This file has been generated by stringres by Metallic Entertainment
// for further information go to http://www.metallic-entertainment.com
//-----------------------------------------------------------------------

#include "tresources.h"

const char *default_face_shader_vert = 
"#version 130\n"
"\n"
"//uniform mat4 gl_TextureMatrix[gl_MaxTextureCoords];\n"
"uniform mat4 gl_ModelViewProjectionMatrix;\n"
"uniform mat4 gl_ModelViewMatrix;\n"
"uniform mat4 gl_ModelViewMatrixInverse;\n"
"\n"
"in vec3 vertex_attr;\n"
"in vec3 vertex2_attr; // vertex of next keyframe\n"
"in vec2 uv_attr;\n"
"in vec3 normal_attr;\n"
"in vec3 tang_attr;\n"
"in vec3 bitang_attr;\n"
"\n"
"uniform float vertex_mix_uni;\n"
"uniform mat4 transformation_uni;\n"
"\n"
"out vec3 pos_var;\n"
"out vec3 normal_var;\n"
"out vec3 tang_var;\n"
"out vec3 bitang_var;\n"
"out vec2 uv_var;\n"
"\n"
"out vec3 cam_pos_var;\n"
"//out vec4 shadow_coord_var;\n"
"\n"
"\n"
"void main(void)\n"
"{\n"
"	vec3 vertex_pos = vertex_attr;\n"
"	if(vertex_mix_uni > 0.0)\n"
"		vertex_pos = vertex_pos * (1.0 - vertex_mix_uni) + vertex2_attr * vertex_mix_uni;\n"
"	vec4 pos = vec4(vertex_pos, 1.0) * transformation_uni;\n"
"	pos_var = pos.xyz;\n"
"	normal_var = normalize(normal_attr * mat3(transformation_uni));\n"
"	tang_var = normalize(tang_attr * mat3(transformation_uni));\n"
"	bitang_var = normalize(bitang_attr * mat3(transformation_uni));\n"
"	uv_var = uv_attr;\n"
"	\n"
"	cam_pos_var = gl_ModelViewMatrixInverse[3].xyz;\n"
"	//shadow_coord_var = gl_TextureMatrix[5] * pos;\n"
"	\n"
"	gl_Position = gl_ModelViewProjectionMatrix * pos;\n"
"}";

const char *default_face_shader_frag = 
"#version 130\n"
"\n"
"// -------------------------------------\n"
"\n"
"//in vec4 TexBorder;\n"
"//in float DiscardBorder;\n"
"\n"
"//in float BumpFactor;\n"
"\n"
"// -------------------------------------\n"
"\n"
"#define M_PI 3.1415926535897932384626433832795\n"
"\n"
"#define MAX_POINT_LIGHTS 8\n"
"#define MAX_DIRECTIONAL_LIGHTS 8\n"
"#define MAX_DIRECTIONAL_SHADOW_SPLITS 8\n"
"\n"
"#define DIRECTIONAL_LIGHT_SHADOW_LAYER_BLEND_DIST 0.5\n"
"\n"
"uniform bool two_side_uni;\n"
"\n"
"uniform vec3 diffuse_color_uni;\n"
"uniform vec4 diffuse_color2_uni;\n"
"uniform vec3 specular_color_uni;\n"
"uniform float ambient_uni;\n"
"uniform float specular_size_uni;\n"
"\n"
"uniform bool diffuse_tex_enabled_uni;\n"
"uniform bool specular_tex_enabled_uni;\n"
"uniform bool normal_tex_enabled_uni;\n"
"\n"
"uniform sampler2D diffuse_tex_uni;\n"
"uniform sampler2D normal_tex_uni;\n"
"uniform sampler2D specular_tex_uni;\n"
"\n"
"uniform int point_light_count_uni;\n"
"uniform vec3 point_light_pos_uni[MAX_POINT_LIGHTS];\n"
"uniform vec3 point_light_color_uni[MAX_POINT_LIGHTS];\n"
"uniform float point_light_distance_uni[MAX_POINT_LIGHTS];\n"
"uniform bool point_light_shadow_enabled_uni[MAX_POINT_LIGHTS];\n"
"uniform samplerCube point_light_shadow_map_uni[MAX_POINT_LIGHTS];\n"
"\n"
"uniform int directional_light_count_uni;\n"
"uniform vec3 directional_light_dir_uni[MAX_DIRECTIONAL_LIGHTS];\n"
"uniform vec3 directional_light_color_uni[MAX_DIRECTIONAL_LIGHTS];\n"
"uniform bool directional_light_shadow_enabled_uni[MAX_DIRECTIONAL_LIGHTS];\n"
"uniform vec2 directional_light_shadow_clip_uni[MAX_DIRECTIONAL_LIGHTS];\n"
"uniform mat4 directional_light_shadow_tex_matrix_uni[MAX_DIRECTIONAL_LIGHTS * MAX_DIRECTIONAL_SHADOW_SPLITS];\n"
"uniform float directional_light_shadow_splits_count_uni[MAX_DIRECTIONAL_LIGHTS];\n"
"uniform float directional_light_shadow_splits_z_uni[MAX_DIRECTIONAL_LIGHTS * (MAX_DIRECTIONAL_SHADOW_SPLITS+1)];\n"
"uniform sampler2DArray directional_light_shadow_map_uni[MAX_DIRECTIONAL_LIGHTS];\n"
"\n"
"uniform vec3 light_ambient_color_uni;\n"
"\n"
"uniform vec3 clip_vec_uni;\n"
"uniform float clip_dist_uni;\n"
"\n"
"\n"
"in vec3 pos_var;\n"
"in vec3 normal_var;\n"
"in vec3 tang_var;\n"
"in vec3 bitang_var;\n"
"in vec2 uv_var;\n"
"\n"
"in vec3 cam_pos_var;\n"
"//in vec4 shadow_coord_var;\n"
"\n"
"out vec4 gl_FragColor;\n"
"\n"
"\n"
"\n"
"float linstep(float min, float max, float v);\n"
"vec4 PointLightShadowLookup(int i, vec3 dir);\n"
"vec4 DirectionalLightShadowLookup(int i, vec3 coord);\n"
"\n"
"\n"
"\n"
"void main(void)\n"
"{\n"
"	if(!gl_FrontFacing && !two_side_uni) // backface culling\n"
"		discard;\n"
"		\n"
"	if(clip_vec_uni != vec3(0.0, 0.0, 0.0)) // face clipping for water\n"
"	{\n"
"		vec3 clip = pos_var - clip_vec_uni * clip_dist_uni;\n"
"		if(dot(clip, clip_vec_uni) >= 0.0)\n"
"			discard;\n"
"	}\n"
"	\n"
"\n"
"	vec3 cam_dir = cam_pos_var - pos_var;\n"
"	float cam_dist = length(cam_dir);\n"
"	cam_dir /= cam_dist;\n"
"	mat3 tangent_space = mat3(tang_var, bitang_var, normal_var);\n"
"				\n"
"	vec4 diffuse_color = vec4(1.0, 1.0, 1.0, 1.0);\n"
"	if(diffuse_tex_enabled_uni)\n"
"		diffuse_color = texture2D(diffuse_tex_uni, uv_var).rgba;\n"
"	diffuse_color *= vec4(diffuse_color_uni.rgb, 1.0);\n"
"	\n"
"	vec3 normal_tex_color = vec3(0.5, 0.5, 1.0);\n"
"	if(normal_tex_enabled_uni)\n"
"		normal_tex_color = texture2D(normal_tex_uni, uv_var).rgb;\n"
"	vec3 specular_tex_color = vec3(0.5, 0.5, 0.5);\n"
"	if(specular_tex_enabled_uni)\n"
"		specular_tex_color = texture2D(specular_tex_uni, uv_var).rgb;\n"
"	\n"
"	vec3 normal = tangent_space * (normal_tex_color - vec3(0.5, 0.5, 0.5)) * 2.0; \n"
"	\n"
"	float alpha = diffuse_color.a; // alpha\n"
"	vec3 color = light_ambient_color_uni * diffuse_color.rgb * ambient_uni; // ambient\n"
"	\n"
"	float light_intensity;\n"
"	float shadow = 1.0;\n"
"	vec3 specular_color;\n"
"	float specular_intensity;\n"
"	int i;\n"
"	float bias;\n"
"	float shadow_depth, light_dist_sq;\n"
"			\n"
"	for(i=0; i<point_light_count_uni; i++)\n"
"	{\n"
"		vec3 light_dir = point_light_pos_uni[i] - pos_var; // pos to light\n"
"		light_dist_sq = light_dir.x * light_dir.x + light_dir.y * light_dir.y + light_dir.z * light_dir.z; // squared distance\n"
"		if(light_dist_sq > point_light_distance_uni[i] * point_light_distance_uni[i])\n"
"			continue;\n"
"		float light_dist = sqrt(light_dist_sq); // real distance\n"
"		light_dir /= light_dist; // normalized dir\n"
"		\n"
"		if(point_light_shadow_enabled_uni[i])\n"
"		{ \n"
"			vec2 moments = PointLightShadowLookup(i, -light_dir).rg;\n"
"			\n"
"			float light_depth = length(point_light_pos_uni[i] - pos_var) / point_light_distance_uni[i];//light_dist / point_light_distance_uni[i];\n"
"									\n"
"			// Surface is fully lit. as the current fragment is before the light occluder\n"
"			if(light_depth <= moments.x)\n"
"				shadow = 1.0;\n"
"			else\n"
"			{\n"
"				float p = smoothstep(light_depth-0.00005, light_depth, moments.x);\n"
"			    float variance = max(moments.y - moments.x*moments.x, -0.001);\n"
"			    float d = light_depth - moments.x;\n"
"			    float p_max = linstep(0.05, 1.0, variance / (variance + d*d));\n"
"			    \n"
"			    shadow = p_max;//clamp(max(p, p_max), 0.0, 1.0);\n"
"			}\n"
"		}\n"
"		else\n"
"			shadow = 1.0;\n"
"	\n"
"		light_intensity = max(dot(normal, light_dir), 0.0) *  (1.0 - light_dist / point_light_distance_uni[i]);\n"
"		color += shadow * light_intensity * point_light_color_uni[i] * diffuse_color.rgb; // diffuse light\n"
"	\n"
"		//specular\n"
"		specular_color = specular_tex_color * specular_color_uni * point_light_color_uni[i];\n"
"		specular_intensity = max(dot(normalize(reflect(-light_dir, normal)), cam_dir), 0.0) * light_intensity;\n"
"		color += max(vec3(0.0, 0.0, 0.0), specular_color * pow(specular_intensity, specular_size_uni)) * shadow;\n"
"	}\n"
"	\n"
"	for(i=0; i<directional_light_count_uni; i++)\n"
"	{		\n"
"		if(directional_light_shadow_enabled_uni[i])\n"
"		{ \n"
"			vec2 coord = vec2(0.0, 0.0);\n"
"			int layer = -1;\n"
"			\n"
"			for(int s=0; s<directional_light_shadow_splits_count_uni[i]; s++)\n"
"			{\n"
"				coord = ((directional_light_shadow_tex_matrix_uni[i*MAX_DIRECTIONAL_SHADOW_SPLITS + s] * vec4(pos_var, 1.0)).xy * 0.5) + vec2(0.5, 0.5);\n"
"				\n"
"				if(!(coord.x < 0.0 || coord.x > 1.0 || coord.y < 0.0 || coord.y > 1.0))\n"
"				{	\n"
"					layer = s;				\n"
"					break;\n"
"				}\n"
"			}\n"
"			\n"
"			if(layer != -1)\n"
"			{\n"
"				vec2 moments = DirectionalLightShadowLookup(i, vec3(coord, float(layer))).rg;\n"
"											\n"
"				float light_dot = (dot(pos_var - cam_pos_var, -directional_light_dir_uni[i]) + directional_light_shadow_clip_uni[i].x) /\n"
"									(directional_light_shadow_clip_uni[i].y - directional_light_shadow_clip_uni[i].x);\n"
"\n"
"				if(light_dot <= moments.x)\n"
"					shadow = 1.0;\n"
"				else\n"
"				{\n"
"					float p = smoothstep(light_dot-0.0005, light_dot, moments.x);\n"
"				    float variance = max(moments.y - moments.x*moments.x, -0.001);\n"
"				    float d = light_dot - moments.x;\n"
"				    float p_max = linstep(0.5, 1.0, variance / (variance + d*d));\n"
"				    \n"
"				   	shadow = clamp(max(p, p_max), 0.0, 1.0);\n"
"				}	\n"
"			}\n"
"			else\n"
"				shadow = 1.0;\n"
"		}\n"
"		else\n"
"			shadow = 1.0;	\n"
"		\n"
"		light_intensity = max(dot(normal, directional_light_dir_uni[i]), 0.0);\n"
"		color += shadow * light_intensity * directional_light_color_uni[i] * diffuse_color.rgb; // diffuse light\n"
"	\n"
"		//specular\n"
"		specular_color = specular_tex_color * specular_color_uni * directional_light_color_uni[i];\n"
"		specular_intensity = max(dot(normalize(reflect(-directional_light_dir_uni[i], normal)), cam_dir), 0.0) * light_intensity;\n"
"		color += max(vec3(0.0, 0.0, 0.0), specular_color * pow(specular_intensity, specular_size_uni)) * shadow;\n"
"	}\n"
"	\n"
"	gl_FragColor = vec4(color, alpha) * diffuse_color2_uni;\n"
"}\n"
"\n"
"\n"
"\n"
"float linstep(float min, float max, float v)\n"
"{\n"
"	return clamp((v - min) / (max - min), 0.0, 1.0);\n"
"}\n"
"\n"
"vec4 PointLightShadowLookup(int i, vec3 dir)\n"
"{\n"
"	switch(i)\n"
"	{\n"
"		case 0: return texture(point_light_shadow_map_uni[0], dir);\n"
"		case 1: return texture(point_light_shadow_map_uni[1], dir);\n"
"		case 2: return texture(point_light_shadow_map_uni[2], dir);\n"
"		case 3: return texture(point_light_shadow_map_uni[3], dir);\n"
"		case 4: return texture(point_light_shadow_map_uni[4], dir);\n"
"		case 5: return texture(point_light_shadow_map_uni[5], dir);\n"
"		case 6: return texture(point_light_shadow_map_uni[6], dir);\n"
"		case 7: return texture(point_light_shadow_map_uni[7], dir);\n"
"	}\n"
"	\n"
"	return vec4(1.0);\n"
"}\n"
"\n"
"vec4 DirectionalLightShadowLookup(int i, vec3 coord)\n"
"{\n"
"	switch(i)\n"
"	{\n"
"		case 0: return texture(directional_light_shadow_map_uni[0], coord);\n"
"		case 1: return texture(directional_light_shadow_map_uni[1], coord);\n"
"		case 2: return texture(directional_light_shadow_map_uni[2], coord);\n"
"		case 3: return texture(directional_light_shadow_map_uni[3], coord);\n"
"		case 4: return texture(directional_light_shadow_map_uni[4], coord);\n"
"		case 5: return texture(directional_light_shadow_map_uni[5], coord);\n"
"		case 6: return texture(directional_light_shadow_map_uni[6], coord);\n"
"		case 7: return texture(directional_light_shadow_map_uni[7], coord);\n"
"	}\n"
"	\n"
"	return vec4(1.0);\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"";

const char *cube_env_shader_vert = 
"varying vec3 Pos;\n"
"\n"
"void main(void)\n"
"{\n"
"	Pos = gl_Vertex.xyz;\n"
"	gl_Position = ftransform();\n"
"}";

const char *cube_env_shader_frag = 
"uniform samplerCube Texture;\n"
"\n"
"varying vec3 Pos;\n"
"\n"
"vec3 pos;\n"
"\n"
"void main(void)\n"
"{\n"
"	vec3 color = textureCube(Texture, normalize(Pos)).xyz;\n"
"	gl_FragColor = vec4(color, 1.0);\n"
"}";

const char *point_shadow_shader_vert = 
"#version 130\n"
"\n"
"uniform mat4 gl_ModelViewProjectionMatrix;\n"
"uniform mat4 gl_ModelViewMatrix;\n"
"uniform mat4 gl_ModelViewMatrixInverse;\n"
"\n"
"in vec3 vertex_attr;\n"
"in vec3 vertex2_attr; // vertex of next keyframe\n"
"\n"
"uniform float vertex_mix_uni;\n"
"uniform mat4 transformation_uni;\n"
"\n"
"out vec3 pos_var;\n"
"\n"
"void main(void)\n"
"{\n"
"	vec3 vertex_pos = vertex_attr;\n"
"	if(vertex_mix_uni > 0.0)\n"
"		vertex_pos = vertex_pos * (1.0 - vertex_mix_uni) + vertex2_attr * vertex_mix_uni;\n"
"		\n"
"	vec4 pos = vec4(vertex_pos, 1.0) * transformation_uni;\n"
"	pos_var = pos.xyz;\n"
"	\n"
"	gl_Position = gl_ModelViewProjectionMatrix * pos;\n"
"}";

const char *point_shadow_shader_frag = 
"#version 130\n"
"\n"
"in vec3 pos_var;\n"
"\n"
"uniform vec3 light_pos_uni;\n"
"uniform float light_dist_uni;\n"
"\n"
"out vec4 gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
"	vec3 dir = pos_var - light_pos_uni;\n"
"	float dist = dir.x * dir.x + dir.y * dir.y + dir.z * dir.z;\n"
"	\n"
"	if(dist > light_dist_uni * light_dist_uni)\n"
"		discard;\n"
"	\n"
"	dist = sqrt(dist) / light_dist_uni;\n"
"	\n"
"	gl_FragColor = vec4(dist, dist*dist, 0.0, 1.0);\n"
"}\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"\n"
"";

const char *point_shadow_blur_shader_vert = 
"#version 130\n"
"\n"
"uniform mat4 gl_ModelViewProjectionMatrix;\n"
"\n"
"in vec4 gl_Vertex;\n"
"\n"
"out vec3 pos_var;\n"
"\n"
"void main(void)\n"
"{\n"
"	pos_var = gl_Vertex.xyz;\n"
"	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n"
"";

const char *point_shadow_blur_shader_frag = 
"#version 130\n"
"\n"
"out vec4 gl_FragColor;\n"
"\n"
"uniform samplerCube tex_uni;\n"
"\n"
"uniform vec3 blur_dir_uni;\n"
"\n"
"in vec3 pos_var;\n"
"\n"
"void main()\n"
"{\n"
"	vec3 coord = pos_var;//normalize(pos_var);\n"
"	vec2 color = vec2(0.0, 0.0);\n"
"	\n"
"	color += texture(tex_uni, coord - blur_dir_uni * 5.0).rg * 0.01;\n"
"	color += texture(tex_uni, coord - blur_dir_uni * 4.0).rg * 0.05;\n"
"	color += texture(tex_uni, coord - blur_dir_uni * 3.0).rg * 0.09;\n"
"	color += texture(tex_uni, coord - blur_dir_uni * 2.0).rg * 0.12;\n"
"	color += texture(tex_uni, coord - blur_dir_uni).rg * 0.15;\n"
"	color += texture(tex_uni, coord).rg * 0.16;\n"
"	color += texture(tex_uni, coord + blur_dir_uni).rg * 0.15;\n"
"	color += texture(tex_uni, coord + blur_dir_uni * 2.0).rg * 0.12;\n"
"	color += texture(tex_uni, coord + blur_dir_uni * 3.0).rg * 0.09;\n"
"	color += texture(tex_uni, coord + blur_dir_uni * 4.0).rg * 0.05;\n"
"	color += texture(tex_uni, coord + blur_dir_uni * 5.0).rg * 0.01;\n"
"	\n"
"	gl_FragColor = vec4(color, 0.0, 1.0);\n"
"}";

const char *directional_shadow_shader_vert = 
"#version 130\n"
"\n"
"uniform mat4 gl_ModelViewProjectionMatrix;\n"
"\n"
"in vec3 vertex_attr;\n"
"in vec3 vertex2_attr; // vertex of next keyframe\n"
"\n"
"uniform float vertex_mix_uni;\n"
"uniform mat4 transformation_uni;\n"
"\n"
"uniform vec3 light_dir_uni;\n"
"uniform vec2 clip_uni;\n"
"uniform vec3 cam_pos_uni;\n"
"\n"
"out float moment1_var;\n"
"\n"
"void main(void)\n"
"{\n"
"	vec3 vertex_pos = vertex_attr;\n"
"	if(vertex_mix_uni > 0.0)\n"
"		vertex_pos = vertex_pos * (1.0 - vertex_mix_uni) + vertex2_attr * vertex_mix_uni;\n"
"	vec4 pos = vec4(vertex_pos, 1.0) * transformation_uni;\n"
"	\n"
"	moment1_var = (dot(pos.xyz - cam_pos_uni, light_dir_uni) + clip_uni.x) / (clip_uni.y - clip_uni.x);\n"
"	\n"
"	gl_Position = gl_ModelViewProjectionMatrix * pos;\n"
"}";

const char *directional_shadow_shader_frag = 
"#version 130\n"
"\n"
"in float moment1_var;\n"
"\n"
"out vec4 gl_FragColor;\n"
"\n"
"void main(void)\n"
"{\n"
"	gl_FragColor = vec4(moment1_var, moment1_var * moment1_var, 0.0, 1.0);\n"
"}\n"
"";

const char *directional_shadow_blur_shader_vert = 
"#version 130\n"
"\n"
"uniform mat4 gl_ModelViewProjectionMatrix;\n"
"\n"
"in vec4 gl_Vertex;\n"
"in vec4 gl_MultiTexCoord0;\n"
"\n"
"out vec2 uv_coord_var;\n"
"\n"
"void main(void)\n"
"{\n"
"	uv_coord_var = gl_MultiTexCoord0.xy;\n"
"	gl_Position = gl_ModelViewProjectionMatrix * gl_Vertex;\n"
"}\n"
"";

const char *directional_shadow_blur_shader_frag = 
"#version 130\n"
"\n"
"#define MAX_LAYERS 8\n"
"\n"
"out vec4 tex_out[MAX_LAYERS]; \n"
"\n"
"uniform sampler2DArray tex_uni;\n"
"\n"
"uniform vec2 blur_dir_uni;\n"
"uniform float blur_factors_uni[MAX_LAYERS];\n"
"uniform int tex_layers_count_uni;\n"
"\n"
"in vec2 uv_coord_var;\n"
"\n"
"void main()\n"
"{\n"
"	vec2 color;\n"
"	float layer;\n"
"	vec2 blur_dir;\n"
"	\n"
"	for(int s=0; s<tex_layers_count_uni; s++)\n"
"	{\n"
"		layer = float(s);\n"
"		color = vec2(0.0, 0.0);\n"
"		blur_dir = blur_dir_uni * blur_factors_uni[s];\n"
"		\n"
"		color += texture(tex_uni, vec3(uv_coord_var - blur_dir * 2.0, layer)).rg * 0.06;\n"
"		color += texture(tex_uni, vec3(uv_coord_var - blur_dir, layer)).rg * 0.24;\n"
"		color += texture(tex_uni, vec3(uv_coord_var, layer)).rg * 0.4;\n"
"		color += texture(tex_uni, vec3(uv_coord_var + blur_dir, layer)).rg * 0.24;\n"
"		color += texture(tex_uni, vec3(uv_coord_var + blur_dir * 2.0, layer)).rg * 0.06;\n"
"		\n"
"		tex_out[s] = vec4(color, 0.0, 1.0);\n"
"	}\n"
"}";

